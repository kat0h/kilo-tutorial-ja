# セットアップ

![assets/lego-step-one.png](assets/lego-step-one.png)

あー、ステップ1。
空っぽのプレートからの新鮮なスタートは好きでないですか？
これから建築するあなた自身の広大な宮殿に載せる1つのブロックを選ぶことは？

残念ながら、あなたが**コンピュータプログラム**を作成するとき、ステップ1は避けられません…
複雑で、イライラしますが、あなたは利用するプログラミング言語の環境が構築されていることを確認してコンパイルして実行する方法を見つけ出す必要があります。

幸運なことに、これから作るプログラムは外部のライブラリに依存していないので、Cコンパイラと付属する標準ライブラリを超えるものは必要ありません。
（`make`プログラムは利用します）

Cコンパイラがインストールされているか確認するために、`cc --version`をコマンドラインで実行してみてください（`cc`は"C Compiler"を意味します）。
また、`make`がインストールされているか確認するために`make -v`も実行してください。

## Cコンパイラのインストール

### ...Windowsで

あなたは**何らかのWindows内Linux環境をインストールする必要**があります。
これは、テキストエディターが`<termios.h>`ヘッダファイル（Windowsで機能しない）を利用して低レベルでターミナルと対話するためです。

[Bash on Windows (WSL)](https://msdn.microsoft.com/en-us/commandline/wsl/about) か
[Cygwin](https://www.cygwin.com/)、
どちらかの利用を推奨します。

**Bash on Windows (WSL)**: 64bitのWindows 10でのみ動作します。
[インストールガイド](https://msdn.microsoft.com/en-us/commandline/wsl/install_guide)を参照してください。

インストール後、Linux環境を起動する際は`bash`を実行してください。
GNUコンパイラコレクションと`make`をインストールするために、`bash`内で`sudo apt-get install gcc make`を実行してください。
もし`sudo`に長い時間がかかる際は、[/etc/hosts ファイルを修正する](https://superuser.com/questions/1108197)必要があるかもしれません。


**Cygwin**: インストーラーを[cygwin.com/install.html](https://cygwin.com/install.html)からダウンロードしてください。
インストラクターがインストールするパッケージの選択を求めた際は、`devel`カテゴリを選択して、`gcc-core`と`make`パッケージを選択してください。

Cygwinを使うには、Cygwinターミナルを実行する必要があります。
Bash on Windows (WSL)とは異なりCygwinではホームディレクトリはWindowsのそれとは分離されています。
もしあなたがCygwinを`C:\cygwin64`にインストールしたならば、ホームディレクトリは`C:\cygwin64\home\yourname`に配置されます。
ですからコードを書くために、Cygwinの外でテキストエディターを使いたい際は、ここが保存場所になります。

### ...macOSで

`cc`コマンドを実行しようとした時、ウィンドウが開きコマンドラインツールをインストールするか聞かれるでしょう。
また、`xcode-select --install`コマンドでもこのウィンドウを開くことができます。
"Install"をクリックすると、Cコンパイラと`make`がインストールされます。

### ...Linuxで

Ubuntuでは、`sudo apt-get install gcc make`でCコンパイラと`make`をインストールできます。
他のディストリビューションでも同じように`gcc`と`make`を利用できます。

## `main()`関数

`kilo.c`と名前をつけた新しいファイルを作成し、`main()`関数を作成してください。
（`kilo`は私たちが作っているテキストエディターの名前です）

```kilo.c
int main() {
  return 0;
}
```

C言語（以下C）では、すべての実行可能コードを関数のなかに入れなくてはなりません。
また`main()`関数は特別で、プログラムを実行する際のデフォルトの開始ポイントになります。
`main()`関数の中で`return`を利用すると、プログラムはOSに整数を返して終了します。
終了コード`0`は成功を示します。

（訳註: Linuxにおいて終了コードは0~255の範囲に限られます）

Cはコンパイル言語です。
これは、プログラムを実行する際Cコンパイラを通して実行ファイルを生成する必要があるということです。
そして、他のコマンドライン上のプログラムと同じように（生成した）ファイルを実行します。

`kilo.c`をコンパイルするには、`cc kilo.c -o kilo`をシェル内で実行します。
エラーが発生しなければ、コンパイラは`kilo`と名付けられた実行ファイルを生成します。
`-o`は"output"（出力）を意味し、出力ファイルが`kilo`と名付けられるように指示します。

`kilo`を実行するには、`./kilo`をシェル内でタイプし、<kbd>Enter</kbd> (しばしば <kbd>return</kbd>)を押します。
プログラムは何も出力しませんが、`echo $?`を実行することで終了ステータス（`main()`関数の返り値）を確認できます。
これにより、`0`が出力されるはずです。


## `make`を利用したコンパイル

コンパイルし直したいとき、毎回`cc kilo.c -o kilo`とタイプするのは退屈です。
`make`プログラムは、ただ`make`を実行するだけでプログラムをコンパイルすることを可能にします。
あなたはただ、`Makefile`にプログラムをどうコンパイルするか書き込むだけです。

`Makefile`と名付けられた新しいファイルを作成し、下記のコードを書き込んでください。

```make
kilo: kilo.c
	$(CC) kilo.c -o kilo -Wall -Wextra -pedantic -std=c99
```

初めの行の`kilo`はビルドしたいものの名前を示し、`kilo.c`がビルドに必要であることを`make`に伝えます。
2行目では`kilo.c`から`kilo`を生成するためのコマンドを記述しています。
字下げは**真のtab文字を利用**することに注意してください。空白文字ではありません。
Cではどちらの文字でも字下げできますが、`Makefile`ではtab文字を使用する必要があります。


コンパイルコマンドについてのいくつかの補足説明:

* `$(CC)`は`make`によって`cc`に展開される変数です。
* `-Wall`は"**all** **W**arnings"（すべての警告）を意味し、コンパイル可能なコードであっても、初期化前変数の利用などC言語にとって悪い書き方と考えられるものを警告します。
* `-Wextra`と`-pedantic`は、更なる警告を有効にします。チュートリアルのそれぞれのステップでは「未使用の変数」以外の警告は出ないようになっています。何か警告を受け取ったらステップのコードと一致しているか確かめてください。
* `-std=c99`はCのバージョンを指定します（**st*an**d**ard）。私たちが使う予定のバージョンは[C99](https://ja.wikipedia.org/wiki/C99)です。C99では関数の中ではどこでも変数を宣言できます。（一方、[AISI C](https://ja.wikipedia.org/wiki/ANSI_C)では変数の宣言を、関数かブロックの先頭で行う必要があります。）

ついに`Makefile`を手に入れました。
`make`を実行してプログラムをコンパイルしてみてください。

おそらく`make: 'kilo' is up to date.`と出力されるでしょう。
これは、現在のバージョンの`kilo.c`はそれぞれのファイルの最終変更タイムスタンプより後にコンパイルされていると判断されたためです。
もし`kilo`が`kilo.c`より後に変更されている場合、`make`は`kilo.c`がすでにコンパイルされていると判断して再度のコンパイルを実行しません。
反対に`kilo.c`が`kilo`より後に変更されている場合は、`make`は`kilo.c`を再度コンパイルします。
これは、1つのファイルを変更してもすべてのファイルをコンパイルする必要のない、たくさんの（コンパイルする必要のある）コンポーネントを持つの大きなプロジェクトでとくに有効です。
1つのコンポーネントだけを変更したときであれば、すべてのファイルをコンパイルし直さずに済むため、たくさんのコンポーネントを持つ大きなプロジェクトでとくに有効です。

`kilo.c`が返す値を`0`ではない数に変えてみてください。
`make`を実行すると、再度コンパイルされるのを確認できるはずです。

`./kilo`を実行して、`echo $?`を確認してください。
変更した値が返されているはずです。

再度`0`を返すように変更し、再コンパイル。
また`0`が返されることを確認してください。

チュートリアルのステップを見た後、`kilo.c`を再コンパイル・エラーがないことを確認し、`./kilo`を実行してみてください。
`./kilo`の再コンパイルを忘れ実行だけして、なぜ`kilo.c`への変更が`./kilo`に反映されていないのか悩むことはありがちです。
`kilo.c`の変更を`./kilo`に反映させるには再コンパイルしなければなりません。

[次のチャプター]()では、ターミナルを*raw mode*にして、ユーザからの入力を読み取るようにします。